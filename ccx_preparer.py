import gmsh
import os

def generate_inp_file(job_name, output_path, geo_results, mat_params, load_params, settings):
    """
    Tworzy plik wsadowy .inp dla CalculiX.
    Korzysta z otwartej sesji Gmsh do pobrania węzłów i elementów.
    """
    
    with open(output_path, 'w') as f:
        f.write(f"** CALCULIX INPUT DECK FOR {job_name}\n")
        f.write("** Generated by Column Optimizer Pro v7\n")
        
        # ----------------------------------------------------------------------
        # 1. WĘZŁY (NODES)
        # ----------------------------------------------------------------------
        f.write("*NODE, NSET=NALL\n")
        
        # Pobieramy węzły z bieżącego modelu Gmsh
        # Jeśli Gmsh został zamknięty, tu wystąpi błąd - założenie: sesja jest otwarta
        nodeTags, nodeCoords, _ = gmsh.model.mesh.getNodes()
        
        for i in range(len(nodeTags)):
            # Format CCX: ID, x, y, z
            f.write(f"{nodeTags[i]}, {nodeCoords[3*i]:.6f}, {nodeCoords[3*i+1]:.6f}, {nodeCoords[3*i+2]:.6f}\n")
            
        # Punkty Referencyjne (RP) - Dodajemy jako nowe, sztuczne węzły
        max_id = max(nodeTags) if len(nodeTags) > 0 else 0
        rp_supp_id = max_id + 1
        rp_load_id = max_id + 2
        
        sx, sy, sz = geo_results['ref_point_support']
        lx, ly, lz = geo_results['ref_point_load']
        
        f.write(f"{rp_supp_id}, {sx:.6f}, {sy:.6f}, {sz:.6f}\n")
        f.write(f"{rp_load_id}, {lx:.6f}, {ly:.6f}, {lz:.6f}\n")
        
        f.write(f"*NSET, NSET=N_RP_SUPPORT\n{rp_supp_id}\n")
        f.write(f"*NSET, NSET=N_RP_LOAD\n{rp_load_id}\n")

        # ----------------------------------------------------------------------
        # 2. ELEMENTY (Separacja 3D vs 2D)
        # ----------------------------------------------------------------------
        phys_groups = gmsh.model.getPhysicalGroups()
        
        for dim, tag in phys_groups:
            name = gmsh.model.getPhysicalName(dim, tag)
            entities = gmsh.model.getEntitiesForPhysicalGroup(dim, tag)
            
            for entity in entities:
                elemTypes, elemTags, elemNodeTags = gmsh.model.mesh.getElements(dim, entity)
                
                for j, eType in enumerate(elemTypes):
                    # Mapowanie typów Gmsh -> CCX
                    ccx_type = ""
                    is_solid = False
                    
                    if eType == 4: ccx_type="C3D4"; is_solid=True
                    elif eType == 11: ccx_type="C3D10"; is_solid=True
                    elif eType == 2: ccx_type="S3"
                    elif eType == 9: ccx_type="S6"
                    
                    if not ccx_type: continue
                    
                    # Nazwa zbioru elementów
                    elset_name = "E_VOL" if is_solid else f"E_SURF_{name}"
                    
                    f.write(f"*ELEMENT, TYPE={ccx_type}, ELSET={elset_name}\n")
                    
                    # Liczba węzłów na element
                    npe = 10 if ccx_type=="C3D10" else (4 if ccx_type=="C3D4" else (6 if ccx_type=="S6" else 3))
                    
                    tags = elemTags[j]
                    nodes = elemNodeTags[j]
                    
                    for k in range(len(tags)):
                        nds = nodes[k*npe : (k+1)*npe]
                        node_str = ", ".join(map(str, nds))
                        f.write(f"{tags[k]}, {node_str}\n")

        # ----------------------------------------------------------------------
        # 3. ZBIORY WĘZŁÓW DLA POWIERZCHNI (Do Rigid Body i Outputu)
        # ----------------------------------------------------------------------
        # Generujemy NSETy dla wszystkich powierzchni nazwanych
        # Te nazwy muszą być zgodne z engine_geometry
        known_surfs = [
            "SUPPORT_FACE", "LOAD_FACE", 
            "CONTACT_C1_Z_POS", "CONTACT_C2_Z_NEG", 
            "FLATBAR_TOP", "WEB_SURFACES", "FLANGES_FREE"
        ]
        
        for s in known_surfs:
            # Tworzymy NSET z węzłów należących do elementów danej powierzchni
            # Zakładamy, że ELSET E_SURF_{s} istnieje (jeśli geometria go wygenerowała)
            f.write(f"*NSET, NSET=N_{s}, ELSET=E_SURF_{s}\n")

        # ----------------------------------------------------------------------
        # 4. MATERIAŁ I SEKCJE
        # ----------------------------------------------------------------------
        mat = mat_params.get('name', 'STEEL')
        E = mat_params.get('E', 210000)
        nu = mat_params.get('nu', 0.3)
        
        # Materiał główny (Stal/Alu)
        f.write(f"*MATERIAL, NAME={mat}\n*ELASTIC\n{E}, {nu}\n")
        f.write(f"*SOLID SECTION, ELSET=E_VOL, MATERIAL={mat}\n")
        
        # Materiał Dummy (Dla elementów 2D - skóra pomiarowa)
        # Bardzo mały moduł Younga, żeby nie usztywniał konstrukcji
        f.write("*MATERIAL, NAME=DUMMY\n*ELASTIC\n1.0, 0.3\n")
        
        for s in known_surfs:
            f.write(f"*SHELL SECTION, ELSET=E_SURF_{s}, MATERIAL=DUMMY\n0.001\n")

        # ----------------------------------------------------------------------
        # 5. WIĘZY (RIGID BODY) I UTWIERDZENIE
        # ----------------------------------------------------------------------
        # Wiążemy całą powierzchnię utwierdzenia z punktem RP_SUPPORT
        f.write(f"*RIGID BODY, NSET=N_SUPPORT_FACE, REF NODE={rp_supp_id}\n")
        # Wiążemy całą powierzchnię obciążenia z punktem RP_LOAD
        f.write(f"*RIGID BODY, NSET=N_LOAD_FACE, REF NODE={rp_load_id}\n")
        
        f.write("*STEP\n*STATIC\n")
        
        # Utwierdzenie punktu RP Support (wszystkie 6 stopni swobody)
        f.write("*BOUNDARY\n")
        f.write(f"{rp_supp_id}, 1, 6\n")

        # ----------------------------------------------------------------------
        # 6. OBCIĄŻENIA (CLOAD)
        # ----------------------------------------------------------------------
        # Siły przykładamy do punktu RP_LOAD
        f.write("*CLOAD\n")
        
        fx = load_params.get('Fx', 0.0)
        fy = load_params.get('Fy', 0.0)
        fz = load_params.get('Fz', 0.0)
        mx = load_params.get('Mx', 0.0)
        my = load_params.get('My', 0.0)
        mz = load_params.get('Mz', 0.0)
        
        if abs(fx) > 1e-5: f.write(f"{rp_load_id}, 1, {fx}\n")
        if abs(fy) > 1e-5: f.write(f"{rp_load_id}, 2, {fy}\n")
        if abs(fz) > 1e-5: f.write(f"{rp_load_id}, 3, {fz}\n")
        if abs(mx) > 1e-5: f.write(f"{rp_load_id}, 4, {mx}\n")
        if abs(my) > 1e-5: f.write(f"{rp_load_id}, 5, {my}\n")
        if abs(mz) > 1e-5: f.write(f"{rp_load_id}, 6, {mz}\n")

        # ----------------------------------------------------------------------
        # 7. OUTPUT
        # ----------------------------------------------------------------------
        # Plik .frd (do wizualizacji)
        f.write("*NODE FILE\nU, RF\n")
        f.write("*EL FILE\nS, E\n")
        
        # Plik .dat (dane liczbowe zbiorcze dla powierzchni)
        for s in known_surfs:
            f.write(f"*NODE PRINT, NSET=N_{s}, TOTALS=YES\nU, RF\n")
            
        f.write("*END STEP\n")